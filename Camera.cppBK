#include "Camera.hpp"
#include <GLM/gtc/matrix_transform.hpp>
#include <GLM/gtx/rotate_vector.hpp>
#include "../CoreDrivers/Screen.hpp"


namespace Toya
{
	namespace Components
	{
		Camera::Camera(Graphics::Window* activeWindow, glm::vec3* pos)
		{
			fieldOfView = farPlane = nearPlane = -1.0f;
			Projection = Perspective;
			_window = activeWindow;
			_aspect = activeWindow->GetWidth() / static_cast<GLfloat>(activeWindow->GetHeight());
			m_Up = glm::vec3(0, 1, 0);
			this->position = *pos;
			this->Reset(*pos, glm::vec3(0, 0, -1), m_Up);
		}
		Camera::Camera(Graphics::Window* activeWindow,glm::vec3*  pos,float fov,float near,float far,ProjectionMode projection_mode,const glm::vec3& initialUp,const glm::vec3& initialCenter)
		{
			fieldOfView = fov;
			nearPlane = near;
			farPlane = far;
			Projection = projection_mode;
			_window = activeWindow;
			_aspect = activeWindow->GetWidth() / static_cast<GLfloat>(activeWindow->GetHeight());
			m_Up = initialUp;
			this->Reset(*pos,initialCenter, m_Up);
		}

		Camera::~Camera()
		{
		}

		Math::Matrix4x4 Camera::GetWorldToViewMatrix() const
		{
			return m_ViewMatrix;
		}

		Math::Matrix4x4 Camera::GetProjcetionMatrix() const
		{
			return m_ProjectionMatrix;
		}	

		glm::vec3 Camera::_getLookDirection() const
		{
			return glm::vec3(-m_Direction);
		}
		void Camera::_rotateAround(glm::vec3& vec, float angleDegrees, glm::vec3& axis) const
		{
			glm::vec3 returnVal;
			angleDegrees *= -(float)Math::PI / 180;
			axis = glm::normalize(axis);
			float c = (float)cos(angleDegrees);
			float s = (float)sin(angleDegrees);
			float t = 1 - c;

			returnVal.x = (t*  (axis.x * axis.x) + c) * vec.x;
			returnVal.x += (t * axis.x * axis.y + s * axis.z) * vec.y;			returnVal.x += (t * axis.x * axis.z - s * axis.y) * vec.z;
			returnVal.y = (t * axis.x * axis.y - s * axis.z) * vec.x;			returnVal.y += (t * (axis.y*axis.y) + c) * vec.y;			returnVal.y += (t * axis.y * axis.z + s * axis.x) * vec.z;
			returnVal.z = (t * axis.x * axis.y + s * axis.y) * vec.x;			returnVal.z += (t * axis.y * axis.z - s * axis.x) * vec.y;			returnVal.z += (t * (axis.z*axis.z) + c) * vec.z;
			vec.x = returnVal.x;			vec.y = returnVal.y;			vec.z = returnVal.z;
		}

		void Camera::Reset(const glm::vec3& position, const glm::vec3& center, const glm::vec3& up)
		{
			//fprintf(stdout, "UP1 -> %f,%f,%f", m_Up.x, m_Up.y, m_Up.z);
			Self->position = position;
			m_Direction = position - center;
			m_Right = glm::cross(m_Up, m_Direction);
			m_Up = glm::cross(m_Direction, m_Right);
			//fprintf(stdout, "UP2 -> %f,%f,%f", m_Up.x, m_Up.y, m_Up.z);
			//Normalizing

			auto upNorm = glm::normalize(m_Up);
			m_Up = glm::vec3(upNorm);
			//fprintf(stdout, "UP3 -> %f,%f,%f", m_Up.x, m_Up.y, m_Up.z);
			auto rightNorm = glm::normalize(m_Right);
			m_Right = glm::vec3(rightNorm);
			auto dirNorm = glm::normalize(m_Direction);
			m_Direction = glm::vec3(dirNorm);
			UpdateViewMatrix();
		}
		void Camera::UpdateViewMatrix()
		{
			glm::vec3 center = Self->position + this->_getLookDirection();
			m_ViewMatrix = Math::Matrix4x4(glm::lookAt(GetTransform()->position, center, m_Up));
		}

		void Camera::SetProjection()
		{
			switch (Projection)
			{
			case Orthographic:
			//	m_ProjectionMatrix = Matrix4x4(glm::ortho(0.0f, CoreDrivers::Screen::ScreenWidth, 0.0f, CoreDrivers::Screen::ScreenHeight, nearPlane, farPlane));
				break;
			case Perspective:
				//fprintf(stdout, "Setting projection, %f, %f, %f, %f, %f\n", fieldOfView, CoreDrivers::Screen::ScreenWidth, CoreDrivers::Screen::ScreenHeight, nearPlane, farPlane);
				if (CoreDrivers::Screen::ScreenWidth != 0)
				{
					m_ProjectionMatrix = Matrix4x4(glm::perspective(fieldOfView, CoreDrivers::Screen::ScreenWidth / static_cast<GLfloat>(CoreDrivers::Screen::ScreenHeight), nearPlane, farPlane));
				}
				break;
			default:;
			}
		}
		void Camera::Slide(float stepR, float stepU, float stepD) const
		{
			Self->position += m_Right *stepR;
			Self->position += m_Up * stepU;
			Self->position += m_Direction * stepD;
		}		void Camera::Yaw(float angleDegrees)
		{			m_Direction = glm::vec3(glm::rotate(m_Direction, angleDegrees, m_Up));			m_Right = glm::vec3(glm::rotate(m_Right, angleDegrees, m_Up));		}

		void Camera::Pitch(float angleDegrees)
		{			m_Up = glm::vec3(glm::rotate(m_Up, angleDegrees, m_Right));			m_Direction = glm::vec3(glm::rotate(m_Direction, angleDegrees, m_Right));		}
		void Camera::Roll(float angleDegrees)
		{			m_Right = glm::vec3(glm::rotate(m_Right, angleDegrees, m_Direction));
			m_Up = glm::vec3(glm::rotate(m_Up, angleDegrees, m_Direction));		}

		void Camera::Walk(float dist) const

		{			Self->position -= glm::vec3(dist * m_Direction);		}

		void Camera::Strafe(float dist) const

		{
			Self->position += m_Right * dist;
		}

		void Camera::Fly(float dist) const

		{
			Self->position += m_Up * dist;
		}


	}
}
